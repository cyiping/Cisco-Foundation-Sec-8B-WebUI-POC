#!/usr/bin/env python3
"""
Pickle Inspector & Editor - Interactive tool for creating and inspecting pickle files

This tool allows users to:
- Create pickle files from scratch
- Navigate and edit with keyboard controls
- Insert opcodes with guided arguments based on pickle protocol
- View real-time stack and memo state
- Validate pickle syntax after each edit
- Load and inspect existing pickle files
"""

import io
import re
import curses
import curses.ascii
import textwrap
import ast
import tempfile
import zipfile
from fickling.fickle import Interpreter, Pickled, Opcode, OPCODE_INFO_BY_NAME
from typing import Any, Optional


# Based on https://github.com/python/cpython/blob/main/Lib/pickle.py
PROTOCOL_INFO = [
    'Original "human-readable" protocol',  # 0
    "Old binary format",  # 1
    "Introduced in Python 2.3",  # 2
    "Default in Python 3.0-3.7",  # 3,
    "Default in Python 3.8",  # 4,
    "Introduced in Python 3.8",  # 5
]

ARGUMENT_PARSE = {
    "decimalnl_short": int,
    "int4": int,
    "uint1": int,
    "uint2": int,
    "decimalnl_long": int,
    "long1": int,
    "long4": int,
    "stringnl": str,
    "string4": str,
    "string1": str,
    "bytes4": bytes,
    "bytes1": bytes,
    "bytes8": bytes,
    "bytearray8": bytearray,
    "unicodestringnl": str,
    "unicodestring1": str,
    "unicodestring4": str,
    "unicodestring8": str,
    "floatnl": float,
    "float8": float,
    "uint4": int,
    "stringnl_noescape_pair": str,
    "uint8": int,
    "stringnl_noescape": str,
}

GLOBAL_COLORS = {
    "op_highlight": (curses.COLOR_WHITE, curses.COLOR_BLUE),
    "menu_highlight": (curses.COLOR_BLACK, curses.COLOR_CYAN),
    "error": (curses.COLOR_WHITE, curses.COLOR_RED),
}

GLOBAL_COLORS_ID = {
    k: i + 1 for i, k in enumerate(GLOBAL_COLORS.keys())
}  # color 0 is reserved


def printable_value(item: Any):
    if isinstance(item, ast.Constant):
        return item.value
    elif isinstance(item, ast.Name):
        return ast.dump(item)
    else:
        return item


class PickleEditorUI:
    def __init__(self, filename):
        self.filename = filename
        self.original_filename = filename
        self.is_pytorch_file = False
        self.pickle_data = None
        self.stdscr = None
        self.current_line = 0
        self.scroll_offset = 0
        self.stack = []
        self.memo = {}
        self.fickled = None
        self.interpreter = None
        self.required_proto = 0
        self.protocol = 0
        self.error = None
        self.unsaved_changes = False
        self.opcode_changes = False

    def load_pickle_lines(self):
        with open(self.filename, "rb") as f:
            data = f.read()

        # Check if this is a ZIP file (PyTorch file)
        try:
            with zipfile.ZipFile(io.BytesIO(data), 'r') as zf:
                # Look for archive/data.pkl (standard PyTorch format)
                if 'archive/data.pkl' in zf.namelist():
                    self.is_pytorch_file = True
                    self.pickle_data = zf.read('archive/data.pkl')
                    data = self.pickle_data
                else:
                    # Try to find any .pkl files (alternative PyTorch formats)
                    pkl_files = [f for f in zf.namelist() if f.endswith('.pkl')]
                    if pkl_files:
                        # Use the first .pkl file found
                        pkl_file = pkl_files[0]
                        self.is_pytorch_file = True
                        self.pickle_data = zf.read(pkl_file)
                        data = self.pickle_data
                    else:
                        # Not a PyTorch file, treat as regular pickle
                        self.is_pytorch_file = False
        except zipfile.BadZipFile:
            # Not a ZIP file, treat as regular pickle
            self.is_pytorch_file = False

        # Check if data is empty or too small
        if len(data) == 0:
            raise Exception("File is empty or pickle data could not be extracted")

        # Load using fickling
        self.fickled = Pickled.load(io.BytesIO(data))

        # determine the protocol from the max required opcode
        self.required_proto = 0
        for o in self.fickled:
            if o.info.proto > self.required_proto:
                self.required_proto = o.info.proto

        self.protocol = self.required_proto

        self.interpreter = Interpreter(self.fickled)
        for _ in range(len(self.fickled)):
            self.interpreter.step()
        self.opcode_changes = True

    def simulate_stack_and_memo(self, upto_line: Optional[int] = None):
        if upto_line is None:
            upto_line = len(self.fickled) - 1

        if self.opcode_changes:
            self.interpreter = Interpreter(self.fickled)
            self.interpreter.step()
            for _ in range(upto_line):
                self.interpreter.step()

        return [printable_value(v) for v in self.interpreter.stack[:upto_line]], {
            k: printable_value(v)
            for k, v in list(self.interpreter.memory.items())[:upto_line]
        }

    def setup_windows(self, stdscr):
        self.stdscr = stdscr
        h, w = stdscr.getmaxyx()
        self.edit_win = curses.newwin(h - 5, w // 2, 0, 0)
        self.stack_win = curses.newwin((h - 5) // 2, w // 2, 0, w // 2)
        self.memo_win = curses.newwin((h - 5) // 2, w // 2, (h - 5) // 2, w // 2)
        self.status_win = curses.newwin(5, w, h - 5, 0)

        for win in [self.edit_win, self.stack_win, self.memo_win]:
            win.keypad(True)

        if curses.has_colors():
            curses.start_color()
            for _name, _id in GLOBAL_COLORS_ID.items():
                color_pair = GLOBAL_COLORS[_name]
                curses.init_pair(_id, color_pair[0], color_pair[1])

    def draw_edit_window(self):
        self.edit_win.clear()
        self.edit_win.box()
        self.edit_win.addstr(0, 2, " Pickle Opcodes ")
        h, w = self.edit_win.getmaxyx()
        view_height = h - 2  # usable lines for content

        # Adjust scroll_offset to keep current_line in view
        if self.current_line < self.scroll_offset:
            self.scroll_offset = self.current_line
        elif self.current_line >= self.scroll_offset + view_height:
            self.scroll_offset = self.current_line - view_height + 1

        for idx in range(
            self.scroll_offset, min(self.scroll_offset + view_height, len(self.fickled))
        ):
            line = self.fickled[idx]
            line_str = f"{idx:03d}: {line.name} {repr(line.arg) if line.arg is not None else ''}"

            color = (
                curses.color_pair(GLOBAL_COLORS_ID["op_highlight"])
                if idx == self.current_line
                else curses.A_NORMAL
            )
            self.edit_win.addstr(
                idx - self.scroll_offset + 1, 2, line_str[: w - 4], color
            )

        self.edit_win.refresh()

    def draw_stack_window(self):
        self.stack_win.clear()
        self.stack_win.box()
        self.stack_win.addstr(0, 2, " Stack ")
        for i, item in enumerate(self.stack[: self.stack_win.getmaxyx()[0] - 2]):
            _line = f"{i:02}: {repr(item)[: self.stack_win.getmaxyx()[1] - 7]}"
            self.stack_win.addstr(i + 1, 2, _line)
        self.stack_win.refresh()

    def draw_memo_window(self):
        self.memo_win.clear()
        self.memo_win.box()
        self.memo_win.addstr(0, 2, " Memo ")
        for i, (k, v) in enumerate(
            list(self.memo.items())[: self.memo_win.getmaxyx()[0] - 2]
        ):
            self.memo_win.addstr(
                i + 1, 2, f"{k}: {v}"[: self.memo_win.getmaxyx()[1] - 4]
            )
        self.memo_win.refresh()

    def draw_status_window(self):
        self.status_win.clear()
        self.status_win.box()
        h, w = self.status_win.getmaxyx()

        status = f" Protocol: {self.protocol} ({PROTOCOL_INFO[self.protocol]})"
        self.status_win.addstr(1, 2, status[: w - 4])

        help_line = " ↑↓:Move  e:Edit  a:Add  x:Delete  s:Save  p:Protocol  ?:Opcode info  w: Write argument to temp file   ESC/q:Quit "
        self.status_win.addstr(2, 2, help_line[: w - 4])

        current_filename = self.filename if hasattr(self, "filename") else "<unnamed>"
        file_type = " (PyTorch)" if self.is_pytorch_file else ""
        filename_display = f"{current_filename}{file_type}"
        self.status_win.addstr(
            3,
            2,
            filename_display[: w - 4],
            curses.color_pair(GLOBAL_COLORS_ID["op_highlight"]),
        )

        # Show error message in red if present
        if getattr(self, "error", None):
            self.status_win.addstr(
                3, 2, self.error[: w - 4], curses.color_pair(GLOBAL_COLORS_ID["error"])
            )
            self.error = None

        self.status_win.refresh()

    def refresh_all(self):
        self.stack, self.memo = self.simulate_stack_and_memo(self.current_line)
        self.draw_edit_window()
        self.draw_stack_window()
        self.draw_memo_window()
        self.draw_status_window()

    def edit_line(self, index):
        new_line = self.prompt_for_opcode_and_arg(filter_text=self.fickled[index].name)
        if new_line is None:
            return  # Cancelled
        self.fickled[index] = new_line
        self.validate_up_to(index)
        self.opcode_changes = True
        self.unsaved_changes = True

    def insert_line(self, index):
        new_line = self.prompt_for_opcode_and_arg()
        if new_line is None:
            return  # Cancelled
        self.fickled.insert(index, new_line)
        self.validate_up_to(index)
        self.opcode_changes = True
        self.unsaved_changes = True

    def validate_up_to(self, line_index):
        try:
            stack, memo = self._simulate_pickle_up_to_line(line_index)
            self.status_message = f"Line {line_index + 1} OK"
        except Exception as e:
            # self.fickled[line_index].valid = False
            self.status_message = f"Line {line_index + 1} ERROR: {e}"

    def prompt_for_opcode_and_arg(self, filter_text=""):
        opcodes = sorted(
            [
                k
                for k, v in OPCODE_INFO_BY_NAME.items()
                if not k.startswith(".") and v.proto <= self.protocol
            ]
        )
        current_selection = 0
        scroll_offset = 0

        h, w = self.stdscr.getmaxyx()
        win_h = min(20, len(opcodes) + 2)
        win_w = 40
        win = curses.newwin(win_h, win_w, (h - win_h) // 2, (w - win_w) // 2)
        win.keypad(True)
        curses.curs_set(0)  # Invisible

        max_visible = win_h - 2

        filtered_opcodes = opcodes[:]
        scroll_offset = 0

        while True:
            # Filter opcodes
            filtered_opcodes = [
                op for op in opcodes if op.startswith(filter_text.upper())
            ]
            if not filtered_opcodes:
                filtered_opcodes = opcodes[:]
            current_selection = min(current_selection, len(filtered_opcodes) - 1)
            max_visible = win_h - 2

            # Scroll logic
            if current_selection < scroll_offset:
                scroll_offset = current_selection
            elif current_selection >= scroll_offset + max_visible:
                scroll_offset = current_selection - max_visible + 1

            visible_opcodes = filtered_opcodes[
                scroll_offset : scroll_offset + max_visible
            ]

            win.clear()
            win.box()
            win.addstr(0, 2, f" Select Opcode: {filter_text.upper()} ")

            for i, opcode in enumerate(visible_opcodes):
                line_y = i + 1
                if scroll_offset + i == current_selection:
                    win.attron(curses.color_pair(GLOBAL_COLORS_ID["menu_highlight"]))
                    win.addstr(line_y, 2, opcode.ljust(win_w - 4))
                    win.attroff(curses.color_pair(GLOBAL_COLORS_ID["menu_highlight"]))
                else:
                    win.addstr(line_y, 2, opcode.ljust(win_w - 4))

            # Draw scrollbar
            total_items = len(filtered_opcodes)
            if total_items > max_visible:
                scrollbar_height = max(1, (max_visible * max_visible) // total_items)
                scrollbar_start = (scroll_offset * max_visible) // total_items
                for i in range(max_visible):
                    char = (
                        "█"
                        if scrollbar_start <= i < scrollbar_start + scrollbar_height
                        else "│"
                    )
                    win.addch(i + 1, win_w - 2, char)

            win.refresh()

            key = win.getch()

            if key == curses.KEY_UP:
                current_selection = (current_selection - 1) % len(filtered_opcodes)
            elif key == curses.KEY_DOWN:
                current_selection = (current_selection + 1) % len(filtered_opcodes)
            elif key in (curses.KEY_ENTER, 10, 13):
                selected = filtered_opcodes[current_selection]
                break
            elif key in (27,):  # ESC
                return None
            elif key in (8, 127, curses.KEY_BACKSPACE):
                filter_text = filter_text[:-1]
                current_selection = 0
            elif 32 <= key <= 126:
                filter_text += chr(key)
                current_selection = 0

        win.clear()
        self.refresh_all()

        value = None  # default to no value

        # Prompt for argument
        if OPCODE_INFO_BY_NAME[selected].arg:
            arg_type = OPCODE_INFO_BY_NAME[selected].arg.name
            python_type = ARGUMENT_PARSE[arg_type]
            prompt = f"Enter a Python literal for {repr(python_type)} for argument of type {arg_type} of {selected}:"

            # Show prompt on stdscr
            self.stdscr.move(h - 3, 2)
            self.stdscr.clrtoeol()
            self.stdscr.addstr(
                h - 3, 2, prompt, curses.color_pair(GLOBAL_COLORS_ID["op_highlight"])
            )

            # Clear and show input area
            self.stdscr.move(h - 2, 2)
            self.stdscr.clrtoeol()
            self.stdscr.refresh()
            curses.echo()
            raw_input = self.stdscr.getstr(h - 2, 2, 80).decode("utf-8").strip()
            curses.noecho()

            # Enter a Python literal for typing.Tuple[str, str] for argument of type stringnl_noescape_pair of GLOBAL:
            try:
                value = ast.literal_eval(raw_input)
                if (
                    isinstance(value, tuple)
                    and len(value) == 2
                    and all(isinstance(x, str) for x in value)
                ):
                    pass
                elif isinstance(value, python_type):
                    pass
                else:
                    raise TypeError(f"Expected {python_type}, got {type(value)}")
            except Exception as e:
                self.error = f"Invalid input: {e}"
                return
            # Invalid input: Subscripted generics cannot be used with class and instance checks

        return Opcode(info=OPCODE_INFO_BY_NAME[selected], argument=value)

    def prompt_for_filename(self):
        current_filename = self.filename if hasattr(self, "filename") else "output.pkl"
        filename = list(current_filename)

        h, w = self.stdscr.getmaxyx()
        status_line = h - 2
        prompt = "Save as: "
        x_start = len(prompt) + 2
        cursor_pos = len(filename)

        # Set up black-on-white color pair for highlighting (if not already set)
        highlight_attr = curses.color_pair(1)

        curses.curs_set(1)  # visible
        curses.noecho()
        self.stdscr.timeout(-1)

        while True:
            # Clear only the area to the end of line
            self.stdscr.move(status_line, 0)
            self.stdscr.clrtoeol()

            # Draw prompt
            self.stdscr.addstr(status_line, 2, prompt)

            # Draw editable filename with highlighting
            self.stdscr.addstr(status_line, x_start, "".join(filename), highlight_attr)

            # Move cursor to correct position within filename
            # TODO handle case for untyped filename (HF cache filenames)
            # self.stdscr.move(status_line, x_start + cursor_pos)
            self.stdscr.refresh()

            key = self.stdscr.getch()

            if key in (10, 13):  # Enter
                curses.curs_set(0)  # Invisible
                return "".join(filename)
            elif key == 27:  # ESC
                return None
            elif key in (curses.KEY_LEFT, 260):
                if cursor_pos > 0:
                    cursor_pos -= 1
            elif key in (curses.KEY_RIGHT, 261):
                if cursor_pos < len(filename):
                    cursor_pos += 1
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if cursor_pos > 0:
                    del filename[cursor_pos - 1]
                    cursor_pos -= 1
            elif key == curses.ascii.DEL or key == 4:  # Ctrl-D or Delete
                if cursor_pos < len(filename):
                    del filename[cursor_pos]
            elif curses.ascii.isprint(key):
                filename.insert(cursor_pos, chr(key))
                cursor_pos += 1
            elif key == curses.KEY_RESIZE:
                self.setup_windows(self.stdscr)
                self.stdscr.refresh()  # Ensure stdscr is rendered immediately
                self.refresh_all()

    def save_lines_to_output(self):
        # Prompt for a filename with default pre-filled
        filename = self.prompt_for_filename()

        # If the user pressed ESC or canceled, return without saving
        if filename is None:
            self.status_message = "Save canceled."
            self.draw_status_window()
            self.stdscr.refresh()
            return
        self.output_filename = filename

        if self.is_pytorch_file:
            # Save as PyTorch file - update the ZIP archive
            self.save_pytorch_file()
        else:
            # Save as regular pickle file
            with open(self.output_filename, "wb") as f:
                self.fickled.dump(f)

        print(f"File saved as {self.output_filename}")
        self.filename = filename
        self.unsaved_changes = False

    def save_pytorch_file(self):
        """Save the modified pickle data back into the PyTorch ZIP file."""
        # Create a temporary buffer for the modified pickle data
        pickle_buffer = io.BytesIO()
        self.fickled.dump(pickle_buffer)
        modified_pickle_data = pickle_buffer.getvalue()

        # Read the original file to preserve other archive members
        with open(self.original_filename, "rb") as f:
            original_data = f.read()

        # Find the original pickle file name
        original_pickle_file = None
        with zipfile.ZipFile(io.BytesIO(original_data), 'r') as original_zip:
            if 'archive/data.pkl' in original_zip.namelist():
                original_pickle_file = 'archive/data.pkl'
            else:
                # Find any .pkl file
                pkl_files = [f for f in original_zip.namelist() if f.endswith('.pkl')]
                if pkl_files:
                    original_pickle_file = pkl_files[0]

        if original_pickle_file is None:
            raise Exception("Could not find original pickle file in ZIP archive")

        # Create a new ZIP file with the modified pickle data
        with zipfile.ZipFile(io.BytesIO(original_data), 'r') as original_zip:
            with zipfile.ZipFile(self.output_filename, 'w') as new_zip:
                # Copy all files except the original pickle file
                for item in original_zip.infolist():
                    if item.filename != original_pickle_file:
                        new_zip.writestr(item, original_zip.read(item.filename))

                # Write the modified pickle data
                new_zip.writestr(original_pickle_file, modified_pickle_data)

    def show_opcode_info(self, name: str):
        h, w = self.stdscr.getmaxyx()
        if name not in OPCODE_INFO_BY_NAME:
            return

        doc = OPCODE_INFO_BY_NAME[name].doc
        doc = re.sub(r"^[ \t]+|[ \t]+$", "", doc, flags=re.MULTILINE)
        margin_y = 2  # lines for title + padding
        margin_x = 4  # space for left and right borders + indentation

        # First, pick a maximum width and wrap lines
        max_win_w = min(80, w - 10)  # prevent overflow
        text_width = max_win_w - margin_x
        wrapped_lines = []
        for line in doc.splitlines():
            wrapped_lines.extend(textwrap.wrap(line, width=text_width))

        win_h = len(wrapped_lines) + margin_y + 1  # +1 for some bottom margin
        win_w = (
            max(
                len(f" Opcode: {name.upper()} "),
                max((len(line) for line in wrapped_lines), default=0),
            )
            + margin_x
        )
        win_h = min(win_h, h - 4)  # don’t exceed screen height
        win_w = min(win_w, w - 4)  # don’t exceed screen width

        win_y = (h - win_h) // 2
        win_x = (w - win_w) // 2

        win = curses.newwin(win_h, win_w, win_y, win_x)
        win.keypad(True)
        win.clear()
        win.box()
        win.addstr(0, 2, f" Opcode: {name.upper()} ")

        for i, line in enumerate(wrapped_lines):
            if 1 + i < win_h - 1:
                win.addstr(1 + i, 2, line)

        win.refresh()
        _ = win.getch()

    def main_loop(self, stdscr):
        self.setup_windows(stdscr)
        self.load_pickle_lines()
        stdscr.refresh()  # Ensure stdscr is rendered immediately
        self.refresh_all()  # Draw immediately

        while True:
            key = stdscr.getch()

            if key == curses.KEY_UP and self.current_line > 0:
                self.current_line -= 1

            elif key == curses.KEY_DOWN and self.current_line < len(self.fickled) - 1:
                self.current_line += 1

            elif key == curses.KEY_END:
                self.current_line = len(self.fickled) - 1

            elif key == curses.KEY_HOME:
                self.current_line = 0

            elif key == curses.KEY_PPAGE:
                h, _ = self.edit_win.getmaxyx()
                self.current_line = max(0, self.current_line - h)

            elif key == curses.KEY_NPAGE:
                h, _ = self.edit_win.getmaxyx()
                self.current_line = min(len(self.fickled) - 1, self.current_line + h)

            elif key in (27, ord("q")):  # ESC or 'q'
                if self.unsaved_changes:  # You should track this flag elsewhere
                    prompt = "Unsaved changes. Are you sure? (y/N)"
                    h, w = self.stdscr.getmaxyx()
                    self.stdscr.addstr(
                        h - 1,
                        2,
                        prompt[: w - 4],
                        curses.color_pair(GLOBAL_COLORS_ID["error"]),
                    )
                    self.stdscr.clrtoeol()
                    self.stdscr.refresh()
                    confirm = self.stdscr.getch()
                    if chr(confirm).lower() != "y":
                        continue  # Cancel exit
                break
            elif key == ord("e") and self.fickled:
                self.edit_line(self.current_line)

            elif key == ord("a"):
                self.insert_line(self.current_line + 1)
                self.current_line += 1

            elif key == ord("x") and self.fickled:
                del self.fickled[self.current_line]
                if self.current_line >= len(self.fickled):
                    self.current_line = max(0, len(self.fickled) - 1)

            elif key == ord("s"):
                self.save_lines_to_output()

            elif key == ord("p"):
                self.protocol += 1
                if self.protocol >= len(PROTOCOL_INFO):
                    self.protocol = self.required_proto

            elif key == ord("?"):
                self.show_opcode_info(self.fickled[self.current_line].name)

            elif key == curses.KEY_RESIZE:
                self.setup_windows(self.stdscr)
                stdscr.refresh()  # Ensure stdscr is rendered immediately

            elif key == ord("w"):
                # create a temporary file
                with tempfile.NamedTemporaryFile(mode="wb", delete=False) as tmp:
                    tempfname = tmp.name  # Save the temp file name
                    argument = self.fickled[self.current_line].arg
                    tmp.write(argument)  # Write the argument to the temporary file

                prompt = (
                    f"Argument info saved to {tempfname}. Press any key to continue"
                )
                h, w = self.stdscr.getmaxyx()
                self.stdscr.addstr(
                    h - 1,
                    2,
                    prompt[: w - 4],
                    curses.color_pair(GLOBAL_COLORS_ID["menu_highlight"]),
                )
                self.stdscr.clrtoeol()
                self.stdscr.refresh()
                confirm = self.stdscr.getch()

            self.refresh_all()


def main():
    import sys

    if len(sys.argv) != 2:
        print("Usage: python pickle_editor.py <filename.pkl>")
        return
    filename = sys.argv[1]
    editor = PickleEditorUI(filename)
    curses.wrapper(editor.main_loop)


if __name__ == "__main__":
    main()
